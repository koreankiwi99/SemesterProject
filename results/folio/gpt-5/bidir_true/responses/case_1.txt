<lean>
axiom obj : Type

-- Entities
axiom Bonnie : obj

-- Predicates
axiom InClub : obj → Prop
axiom PerformOften : obj → Prop
axiom AttendEngaged : obj → Prop
axiom Inactive : obj → Prop
axiom Chaperone : obj → Prop
axiom Student : obj → Prop
axiom YoungChild : obj → Prop
axiom Teenager : obj → Prop
axiom Wishes : obj → Prop

-- Axioms from the context
axiom A1 : ∀ x : obj, InClub x ∧ PerformOften x → AttendEngaged x
axiom A2 : ∀ x : obj, InClub x → (PerformOften x ∨ Inactive x)
axiom A3 : ∀ x : obj, InClub x ∧ Chaperone x → ¬ Student x
axiom A4 : ∀ x : obj, InClub x ∧ Inactive x → Chaperone x
axiom A5 : ∀ x : obj, InClub x ∧ ((YoungChild x ∨ Teenager x) ∧ Wishes x) → Student x

-- Bonnie-specific information
axiom A6 :
  InClub Bonnie ∧
  ((AttendEngaged Bonnie ∧ Student Bonnie) ∨ ¬ (AttendEngaged Bonnie ∧ ¬ Student Bonnie))

open Classical

theorem bonnie_statement :
  (((YoungChild Bonnie ∨ Teenager Bonnie) ∧ Wishes Bonnie ∧ Chaperone Bonnie) ∨
   ¬ ((YoungChild Bonnie ∨ Teenager Bonnie) ∧ Wishes Bonnie)) →
  (Student Bonnie ∨ Inactive Bonnie) := by
  intro _
  have hClub : InClub Bonnie := And.left A6
  have hBonSpec :
    (AttendEngaged Bonnie ∧ Student Bonnie) ∨ ¬ (AttendEngaged Bonnie ∧ ¬ Student Bonnie) :=
    And.right A6
  have hPOorI : PerformOften Bonnie ∨ Inactive Bonnie := A2 Bonnie hClub
  cases hPOorI with
  | inr hInact =>
      exact Or.inr hInact
  | inl hPerf =>
      have hAttend : AttendEngaged Bonnie := A1 Bonnie ⟨hClub, hPerf⟩
      cases hBonSpec with
      | inl hAEStu =>
          exact Or.inl hAEStu.right
      | inr hNot =>
          by_cases hS : Student Bonnie
          · exact Or.inl hS
          ·
            have hFalse : False := hNot ⟨hAttend, hS⟩
            exact Or.inl (False.elim hFalse)
</lean>

ANSWER: True
