<lean>
axiom obj : Type
axiom Harry : obj

axiom Invertebrate : obj → Prop
axiom Vertebrate : obj → Prop
axiom Backbone : obj → Prop
axiom MFRepro : obj → Prop
axiom Bee : obj → Prop
axiom QueenBee : obj → Prop

-- Premises
axiom A1 : ∀ x : obj, Invertebrate x ∨ Vertebrate x
axiom A2 : ∀ x : obj, Backbone x → MFRepro x
axiom A3 : ∀ x : obj, Vertebrate x → Backbone x
axiom A4 : ∀ x : obj, Bee x → ¬ MFRepro x
axiom A5 : ∀ x : obj, QueenBee x → Bee x
axiom A6 : Bee Harry

theorem not_backbone_h : ¬Backbone Harry := by
  intro hb
  have mf : MFRepro Harry := A2 Harry hb
  have n : ¬ MFRepro Harry := A4 Harry A6
  exact n mf

theorem not_vertebrate_h : ¬Vertebrate Harry := by
  intro hv
  apply not_backbone_h
  exact A3 Harry hv

theorem P_holds :
  (Vertebrate Harry ∧ Backbone Harry) ∨ (¬Vertebrate Harry ∧ ¬Backbone Harry) := by
  apply Or.inr
  apply And.intro
  · exact not_vertebrate_h
  · exact not_backbone_h

theorem not_Q : ¬(¬Invertebrate Harry ∧ ¬QueenBee Harry) := by
  intro h
  have disj : Invertebrate Harry ∨ Vertebrate Harry := A1 Harry
  cases disj with
  | inl inv =>
      exact (And.left h) inv
  | inr vert =>
      exact not_vertebrate_h vert

theorem neg_statement :
  ¬ ( ((Vertebrate Harry ∧ Backbone Harry) ∨ (¬ Vertebrate Harry ∧ ¬ Backbone Harry))
      → (¬Invertebrate Harry ∧ ¬QueenBee Harry) ) := by
  intro himpl
  have q : (¬Invertebrate Harry ∧ ¬QueenBee Harry) := himpl P_holds
  exact not_Q q
</lean>

ANSWER: False
