<lean>
axiom obj : Type

-- objects and predicates
axiom DriedThaiChilies : obj
axiom BakedSweet : obj → Prop
axiom Spicy : obj → Prop
axiom Cupcake : obj → Prop
axiom MalaHotpot : obj → Prop
axiom MelissaProduct : obj → Prop

-- premises
axiom P1 : ∀ x : obj, BakedSweet x → ¬ Spicy x                     -- No baked sweets are spicy
axiom P2 : ∀ x : obj, Cupcake x → BakedSweet x                      -- All cupcakes are baked sweets
axiom P3 : ∀ x : obj, MalaHotpot x → Spicy x                        -- All mala hotpots are spicy
axiom P4 : ∀ x : obj, MelissaProduct x → Cupcake x                  -- All products from Baked by Melissa are cupcakes
axiom P5 : Spicy DriedThaiChilies ∨ MalaHotpot DriedThaiChilies ∨ ¬ BakedSweet DriedThaiChilies
  -- Dried Thai chilies are spicy or mala hotpots or not baked sweets

-- goal: Dried Thai chilies are neither products of Baked by Melissa nor baked sweets.
theorem dried_thai_chilies_neither_melissa_nor_baked :
  ¬ MelissaProduct DriedThaiChilies ∧ ¬ BakedSweet DriedThaiChilies := by
  -- First show ¬ BakedSweet DriedThaiChilies
  have h_not_bs : ¬ BakedSweet DriedThaiChilies := by
    cases P5 with
    | inl hSpicy =>
        exact (fun hbs => (P1 DriedThaiChilies hbs) hSpicy)
    | inr h2 =>
        cases h2 with
        | inl hMala =>
            have hSp : Spicy DriedThaiChilies := P3 DriedThaiChilies hMala
            exact (fun hbs => (P1 DriedThaiChilies hbs) hSp)
        | inr hnb => exact hnb
  -- Then show ¬ MelissaProduct DriedThaiChilies using implication to BakedSweet
  have h_not_mel : ¬ MelissaProduct DriedThaiChilies := by
    intro hmel
    have hcup : Cupcake DriedThaiChilies := P4 DriedThaiChilies hmel
    have hbs  : BakedSweet DriedThaiChilies := P2 DriedThaiChilies hcup
    exact h_not_bs hbs
  exact And.intro h_not_mel h_not_bs
</lean>

ANSWER: True
