<lean>
axiom obj : Type
axiom Luke : obj

axiom BornMultiple : obj → Prop
axiom SpendTimeWithSiblings : obj → Prop
axiom LiveAtHome : obj → Prop
axiom LiveWithStrangers : obj → Prop
axiom HaveSiblingsBornTogether : obj → Prop
axiom ComplainOftenAboutAnnoyingSiblings : obj → Prop

-- Axioms from the context
axiom A1 : ∀ x : obj, BornMultiple x → SpendTimeWithSiblings x
axiom A2 : ∀ x : obj, SpendTimeWithSiblings x → LiveAtHome x
axiom A3 : ∀ x : obj, LiveAtHome x → ¬LiveWithStrangers x
axiom A4 : ∀ x : obj, HaveSiblingsBornTogether x → BornMultiple x
axiom A5 : ∀ x : obj, ComplainOftenAboutAnnoyingSiblings x → HaveSiblingsBornTogether x

-- Luke-specific disjunction
axiom LukeOr :
  (BornMultiple Luke ∧ LiveWithStrangers Luke) ∨ (¬BornMultiple Luke ∧ ¬LiveWithStrangers Luke)

theorem luke_neither_multiple_nor_complains :
  ¬BornMultiple Luke ∧ ¬ComplainOftenAboutAnnoyingSiblings Luke := by
  -- From BornMultiple ⇒ SpendTime ⇒ LiveAtHome ⇒ ¬LiveWithStrangers
  have h_not_strangers : ∀ x : obj, BornMultiple x → ¬LiveWithStrangers x :=
    fun x hbm => A3 x (A2 x (A1 x hbm))
  -- Derive ¬BornMultiple Luke from the disjunction and the chain above
  have h_not_born : ¬BornMultiple Luke := by
    cases LukeOr with
    | inl h =>
        -- h.left : BornMultiple Luke, h.right : LiveWithStrangers Luke
        apply False.elim
        have nls : ¬LiveWithStrangers Luke := h_not_strangers Luke h.left
        exact nls h.right
    | inr h =>
        exact h.left
  -- Using ¬BornMultiple Luke, show ¬ComplainOftenAboutAnnoyingSiblings Luke
  have h_not_complain : ¬ComplainOftenAboutAnnoyingSiblings Luke := by
    intro hc
    have h_sibs := A5 Luke hc
    have h_born := A4 Luke h_sibs
    exact h_not_born h_born
  exact And.intro h_not_born h_not_complain
</lean>

ANSWER: True
