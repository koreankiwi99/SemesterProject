======================================================================
STAGE 1: TRANSLATION
======================================================================

--- Iteration 1 ---

<lean>
axiom obj : Type

axiom AtMarysSchool : obj → Prop
axiom WorksStudentJobsOnCampus : obj → Prop
axiom NeedsToEarnMoneyForTuition : obj → Prop
axiom OrdersTakeoutFrequentlyInCollege : obj → Prop
axiom EnjoysDiningHallMealsRecipes : obj → Prop
axiom NotPickyEater : obj → Prop
axiom SpendsTimeEatingWithFriendsInDiningHalls : obj → Prop

axiom Hannah : obj

-- Premises
axiom P1 : ∀ x : obj, AtMarysSchool x → WorksStudentJobsOnCampus x → NeedsToEarnMoneyForTuition x
axiom P2 : ∀ x : obj, AtMarysSchool x → OrdersTakeoutFrequentlyInCollege x → WorksStudentJobsOnCampus x
axiom P3 : ∀ x : obj, AtMarysSchool x → (OrdersTakeoutFrequentlyInCollege x ∨ EnjoysDiningHallMealsRecipes x)
axiom P4 : ∀ x : obj, AtMarysSchool x → EnjoysDiningHallMealsRecipes x → NotPickyEater x
axiom P5 : ∀ x : obj, AtMarysSchool x → EnjoysDiningHallMealsRecipes x → SpendsTimeEatingWithFriendsInDiningHalls x
axiom P6 : AtMarysSchool Hannah
axiom P7 : WorksStudentJobsOnCampus Hannah ∧ (NeedsToEarnMoneyForTuition Hannah → (NotPickyEater Hannah ∧ ¬NeedsToEarnMoneyForTuition Hannah))

-- Conclusion
theorem goal :
  AtMarysSchool Hannah ∧
  (NotPickyEater Hannah ∨ (¬NotPickyEater Hannah → SpendsTimeEatingWithFriendsInDiningHalls Hannah)) := sorry
</lean>


======================================================================
STAGE 2: PROVING
======================================================================

--- Iteration 1 ---

<lean>
axiom obj : Type

axiom AtMarysSchool : obj → Prop
axiom WorksStudentJobsOnCampus : obj → Prop
axiom NeedsToEarnMoneyForTuition : obj → Prop
axiom OrdersTakeoutFrequentlyInCollege : obj → Prop
axiom EnjoysDiningHallMealsRecipes : obj → Prop
axiom NotPickyEater : obj → Prop
axiom SpendsTimeEatingWithFriendsInDiningHalls : obj → Prop

axiom Hannah : obj

-- Premises
axiom P1 : ∀ x : obj, AtMarysSchool x → WorksStudentJobsOnCampus x → NeedsToEarnMoneyForTuition x
axiom P2 : ∀ x : obj, AtMarysSchool x → OrdersTakeoutFrequentlyInCollege x → WorksStudentJobsOnCampus x
axiom P3 : ∀ x : obj, AtMarysSchool x → (OrdersTakeoutFrequentlyInCollege x ∨ EnjoysDiningHallMealsRecipes x)
axiom P4 : ∀ x : obj, AtMarysSchool x → EnjoysDiningHallMealsRecipes x → NotPickyEater x
axiom P5 : ∀ x : obj, AtMarysSchool x → EnjoysDiningHallMealsRecipes x → SpendsTimeEatingWithFriendsInDiningHalls x
axiom P6 : AtMarysSchool Hannah
axiom P7 : WorksStudentJobsOnCampus Hannah ∧ (NeedsToEarnMoneyForTuition Hannah → (NotPickyEater Hannah ∧ ¬NeedsToEarnMoneyForTuition Hannah))

-- Conclusion
theorem goal :
  AtMarysSchool Hannah ∧
  (NotPickyEater Hannah ∨ (¬NotPickyEater Hannah → SpendsTimeEatingWithFriendsInDiningHalls Hannah)) := by
  apply And.intro
  · exact P6
  ·
    have hSchool : AtMarysSchool Hannah := P6
    have hdisj : OrdersTakeoutFrequentlyInCollege Hannah ∨ EnjoysDiningHallMealsRecipes Hannah := P3 Hannah hSchool
    have hNotPicky : NotPickyEater Hannah := by
      cases hdisj with
      | inl hOrders =>
        have hWorks : WorksStudentJobsOnCampus Hannah := P2 Hannah hSchool hOrders
        have hNeeds : NeedsToEarnMoneyForTuition Hannah := P1 Hannah hSchool hWorks
        have hImp : NeedsToEarnMoneyForTuition Hannah → (NotPickyEater Hannah ∧ ¬NeedsToEarnMoneyForTuition Hannah) := And.right P7
        have hPair : NotPickyEater Hannah ∧ ¬NeedsToEarnMoneyForTuition Hannah := hImp hNeeds
        exact And.left hPair
      | inr hEnjoys =>
        exact P4 Hannah hSchool hEnjoys
    exact Or.inl hNotPicky
</lean>
ANSWER: True
