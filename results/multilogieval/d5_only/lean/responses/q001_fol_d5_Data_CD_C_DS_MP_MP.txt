Multi-LogiEval Question with Lean Verification
================================================================================

Logic Type: fol
Depth: d5 (d5_Data)
Rule: CD_C_DS_MP_MP

Context:
At the office, if someone finishes their project ahead of schedule, they can take a long lunch break. Also, if it's a coworker's birthday, people will bring in treats to celebrate. Either projects get done early, or it's a birthday, or maybe both. So if someone takes a nice long lunch, they'll come back feeling recharged. And if they come back recharged, they'll have a very productive afternoon.

Question:
If John did not bring in treats to celebrate, did he have a very productive afternoon?

================================================================================
Iterations:
================================================================================

--- Iteration 1 ---

LLM Response:
<lean>
axiom Person : Type
axiom John : Person

axiom FinishEarly : Person → Prop
axiom LongLunch : Person → Prop
axiom Recharged : Person → Prop
axiom Productive : Person → Prop
axiom BringTreats : Person → Prop
axiom Birthday : Prop

-- If someone finishes early, they (do) take a long lunch.
axiom finish_implies_lunch : ∀ x : Person, FinishEarly x → LongLunch x
-- If it's a birthday, then everyone brings treats.
axiom birthday_implies_bring : Birthday → ∀ x : Person, BringTreats x
-- For each person, either they finish early or it's a birthday (or both).
axiom either_finish_or_birthday : ∀ x : Person, FinishEarly x ∨ Birthday
-- If someone takes a long lunch, they come back recharged.
axiom lunch_implies_recharged : ∀ x : Person, LongLunch x → Recharged x
-- If someone is recharged, they have a very productive afternoon.
axiom recharged_implies_productive : ∀ x : Person, Recharged x → Productive x

theorem John_productive_if_not_bring : ¬ BringTreats John → Productive John := by
  intro hNotBring
  -- From "birthday -> everyone brings treats" and "John did not bring treats",
  -- infer it's not a birthday.
  have hNotBirthday : ¬ Birthday := by
    intro b
    have hAll : ∀ x, BringTreats x := birthday_implies_bring b
    exact hNotBring (hAll John)
  -- From either_finish_or_birthday and not birthday, deduce John finished early.
  have feJohn : FinishEarly John := by
    have h := either_finish_or_birthday John
    cases h with
    | inl fe => exact fe
    | inr b  => exact False.elim (hNotBirthday b)
  -- Chain the implications to get productivity.
  have ll : LongLunch John := finish_implies_lunch John feJohn
  have r  : Recharged John := lunch_implies_recharged John ll
  have p  : Productive John := recharged_implies_productive John r
  exact p
</lean>
ANSWER: Yes

Extracted Lean Code:
----------------------------------------
axiom Person : Type
axiom John : Person

axiom FinishEarly : Person → Prop
axiom LongLunch : Person → Prop
axiom Recharged : Person → Prop
axiom Productive : Person → Prop
axiom BringTreats : Person → Prop
axiom Birthday : Prop

-- If someone finishes early, they (do) take a long lunch.
axiom finish_implies_lunch : ∀ x : Person, FinishEarly x → LongLunch x
-- If it's a birthday, then everyone brings treats.
axiom birthday_implies_bring : Birthday → ∀ x : Person, BringTreats x
-- For each person, either they finish early or it's a birthday (or both).
axiom either_finish_or_birthday : ∀ x : Person, FinishEarly x ∨ Birthday
-- If someone takes a long lunch, they come back recharged.
axiom lunch_implies_recharged : ∀ x : Person, LongLunch x → Recharged x
-- If someone is recharged, they have a very productive afternoon.
axiom recharged_implies_productive : ∀ x : Person, Recharged x → Productive x

theorem John_productive_if_not_bring : ¬ BringTreats John → Productive John := by
  intro hNotBring
  -- From "birthday -> everyone brings treats" and "John did not bring treats",
  -- infer it's not a birthday.
  have hNotBirthday : ¬ Birthday := by
    intro b
    have hAll : ∀ x, BringTreats x := birthday_implies_bring b
    exact hNotBring (hAll John)
  -- From either_finish_or_birthday and not birthday, deduce John finished early.
  have feJohn : FinishEarly John := by
    have h := either_finish_or_birthday John
    cases h with
    | inl fe => exact fe
    | inr b  => exact False.elim (hNotBirthday b)
  -- Chain the implications to get productivity.
  have ll : LongLunch John := finish_implies_lunch John feJohn
  have r  : Recharged John := lunch_implies_recharged John ll
  have p  : Productive John := recharged_implies_productive John r
  exact p
----------------------------------------

Lean Verification:
  Success: True

================================================================================
Final Result:
================================================================================
Ground Truth: Yes
Prediction: Yes
Correct: ✓ Yes
Total Iterations: 1
Final Lean: ✓ Success
