<lean>
axiom obj : Type
axiom Matt : obj

axiom WatchDIY : obj → Prop
axiom ReadBlogs : obj → Prop
axiom Skills : obj → Prop
axiom RedoLivingRoom : obj → Prop
axiom NewIdeas : obj → Prop

-- If someone watches DIY videos, they gain decorating skills.
axiom R1 : ∀ x : obj, WatchDIY x → Skills x
-- With these skills, they can redo their living room.
axiom R2 : ∀ x : obj, Skills x → RedoLivingRoom x
-- Either they watched DIY videos, or they read interior design blogs, or both (for Matt).
axiom D1 : WatchDIY Matt ∨ ReadBlogs Matt
-- If someone reads interior design blogs, then they get new decorating ideas.
axiom R3 : ∀ x : obj, ReadBlogs x → NewIdeas x

theorem matt_gets_new_ideas : ¬RedoLivingRoom Matt → NewIdeas Matt := by
  intro hNotRedo
  -- From not redoing and (skills → redo), we get not skills
  have hNotSkills : ¬Skills Matt := by
    intro hSkills
    exact hNotRedo (R2 Matt hSkills)
  -- From (watch → skills) and not skills, we get not watch
  have hNotWatch : ¬WatchDIY Matt := by
    intro hWatch
    exact hNotSkills (R1 Matt hWatch)
  -- From (watch ∨ read) and not watch, we get read
  have hRead : ReadBlogs Matt := by
    exact Or.elim D1 (fun hW => False.elim (hNotWatch hW)) (fun hR => hR)
  -- From read, we get new ideas
  exact R3 Matt hRead
</lean>

ANSWER: Yes
