<lean>
axiom obj : Type
axiom BakedSweet : obj → Prop
axiom Spicy : obj → Prop
axiom Cupcake : obj → Prop
axiom MalaHotpot : obj → Prop
axiom FromBBM : obj → Prop
axiom DTC : obj  -- Dried Thai chilies

-- No baked sweets are spicy.
axiom A1 : ∀ x : obj, BakedSweet x → ¬ Spicy x
-- All cupcakes are baked sweets.
axiom A2 : ∀ x : obj, Cupcake x → BakedSweet x
-- All mala hotpots are spicy.
axiom A3 : ∀ x : obj, MalaHotpot x → Spicy x
-- All products from Baked by Melissa are cupcakes.
axiom A4 : ∀ x : obj, FromBBM x → Cupcake x
-- Dried Thai chilies are spicy or mala hotpots or not baked sweets.
axiom A5 : Spicy DTC ∨ (MalaHotpot DTC ∨ ¬ BakedSweet DTC)

theorem dtc_neither_bbm_nor_baked : ¬ FromBBM DTC ∧ ¬ BakedSweet DTC := by
  -- Reduce the trichotomy to (Spicy DTC ∨ ¬ BakedSweet DTC)
  have hS_or_notB : Spicy DTC ∨ ¬ BakedSweet DTC := by
    cases A5 with
    | inl hS => exact Or.inl hS
    | inr h =>
      cases h with
      | inl hM =>
        have hS : Spicy DTC := A3 DTC hM
        exact Or.inl hS
      | inr hNotB => exact Or.inr hNotB
  -- From "no baked sweets are spicy", derive "spicy implies not baked sweet"
  have hS_implies_notB : Spicy DTC → ¬ BakedSweet DTC := by
    intro hS
    intro hB
    have hNotS : ¬ Spicy DTC := A1 DTC hB
    exact hNotS hS
  -- Conclude not baked sweet
  have hNotB : ¬ BakedSweet DTC := by
    cases hS_or_notB with
    | inl hS => exact hS_implies_notB hS
    | inr hNotB => exact hNotB
  -- FromBBM implies BakedSweet
  have hF_implies_B : FromBBM DTC → BakedSweet DTC := by
    intro hF
    exact A2 DTC (A4 DTC hF)
  -- Hence not FromBBM
  have hNotF : ¬ FromBBM DTC := by
    intro hF
    apply hNotB
    exact hF_implies_B hF
  exact And.intro hNotF hNotB
</lean>

ANSWER: True
