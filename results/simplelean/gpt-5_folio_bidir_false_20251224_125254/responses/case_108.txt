<lean>
axiom obj : Type
axiom Peter : obj

axiom Spill : obj → Prop
axiom Tidy : obj → Prop
axiom Cleanly : obj → Prop
axiom ValueOrder : obj → Prop
axiom Family : obj → Prop
axiom CF : obj → Prop

-- If people spill a lot of food on their clothing, then they are not notably tidy.
axiom A1 : ∀ x : obj, Spill x → ¬Tidy x
-- All clumsy foodies who go out frequently to find new food restaurants to try spill a lot.
axiom A2 : ∀ x : obj, CF x → Spill x
-- If people are cleanly, then they are notably tidy.
axiom A3 : ∀ x : obj, Cleanly x → Tidy x
-- If people value order and spotlessness, then they are cleanly.
axiom A4 : ∀ x : obj, ValueOrder x → Cleanly x
-- All people whose families prioritize order and spotlessness themselves value order and spotlessness.
axiom A5 : ∀ x : obj, Family x → ValueOrder x
-- Peter is either (spills and is cleanly) or (doesn't spill and isn't cleanly).
axiom A6 : (Spill Peter ∧ Cleanly Peter) ∨ (¬Spill Peter ∧ ¬Cleanly Peter)

-- Prove the negation of the statement: CF Peter ∨ Family Peter
theorem neg_conclusion : ¬(CF Peter ∨ Family Peter) := by
  cases A6 with
  | inl hsc =>
    have hS : Spill Peter := hsc.left
    have hC : Cleanly Peter := hsc.right
    have hNotT : ¬Tidy Peter := A1 Peter hS
    have hT : Tidy Peter := A3 Peter hC
    have contra : False := hNotT hT
    intro _
    exact False.elim contra
  | inr hnot =>
    have hns : ¬Spill Peter := hnot.left
    have hnc : ¬Cleanly Peter := hnot.right
    have hnotcf : ¬CF Peter := fun hcf => hns (A2 Peter hcf)
    have hnotfam : ¬Family Peter := fun hf => hnc (A4 Peter (A5 Peter hf))
    intro h
    cases h with
    | inl hcf => exact hnotcf hcf
    | inr hf  => exact hnotfam hf
</lean>

ANSWER: False
