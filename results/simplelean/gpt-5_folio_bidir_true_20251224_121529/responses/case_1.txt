<lean>
axiom obj : Type

-- Predicates
axiom InClub : obj → Prop
axiom PerformsOften : obj → Prop
axiom EngagedEvents : obj → Prop
axiom InactiveDisinterested : obj → Prop
axiom ChaperoneDances : obj → Prop
axiom StudentAttendsSchool : obj → Prop
axiom YoungChild : obj → Prop
axiom Teenager : obj → Prop
axiom WishesAcademic : obj → Prop

-- Axioms from the context
axiom A1 : ∀ x : obj, InClub x → PerformsOften x → EngagedEvents x
axiom A2 : ∀ x : obj, InClub x → (PerformsOften x ∨ InactiveDisinterested x)
axiom A3 : ∀ x : obj, InClub x → ChaperoneDances x → ¬ StudentAttendsSchool x
axiom A4 : ∀ x : obj, InClub x → InactiveDisinterested x → ChaperoneDances x
axiom A5 : ∀ x : obj, InClub x → ((YoungChild x ∨ Teenager x) ∧ WishesAcademic x) → StudentAttendsSchool x

-- Bonnie and her properties
axiom Bonnie : obj
axiom B_in : InClub Bonnie
axiom B_extra : (EngagedEvents Bonnie ∧ StudentAttendsSchool Bonnie) ∨ ¬ (EngagedEvents Bonnie ∧ ¬ StudentAttendsSchool Bonnie)

open Classical

theorem bonnie_statement :
  (((YoungChild Bonnie ∨ Teenager Bonnie) ∧ WishesAcademic Bonnie ∧ ChaperoneDances Bonnie)
    ∨ ¬ ((YoungChild Bonnie ∨ Teenager Bonnie) ∧ WishesAcademic Bonnie))
  → (StudentAttendsSchool Bonnie ∨ InactiveDisinterested Bonnie) := by
  intro _
  have hA2 : PerformsOften Bonnie ∨ InactiveDisinterested Bonnie := A2 Bonnie B_in
  cases hA2 with
  | inl hPerf =>
      have hEng : EngagedEvents Bonnie := A1 Bonnie B_in hPerf
      cases B_extra with
      | inl hES =>
          exact Or.inl hES.right
      | inr hNot =>
          have hStu : StudentAttendsSchool Bonnie := by
            by_contra hn
            exact hNot ⟨hEng, hn⟩
          exact Or.inl hStu
  | inr hInact =>
      exact Or.inr hInact
</lean>

ANSWER: True

======================================================================
ITERATION 2
======================================================================

<lean>
axiom obj : Type

-- Predicates
axiom InClub : obj → Prop
axiom PerformsOften : obj → Prop
axiom EngagedEvents : obj → Prop
axiom InactiveDisinterested : obj → Prop
axiom ChaperoneDances : obj → Prop
axiom StudentAttendsSchool : obj → Prop
axiom YoungChild : obj → Prop
axiom Teenager : obj → Prop
axiom WishesAcademic : obj → Prop

-- Axioms from the context
axiom A1 : ∀ x : obj, InClub x → PerformsOften x → EngagedEvents x
axiom A2 : ∀ x : obj, InClub x → (PerformsOften x ∨ InactiveDisinterested x)
axiom A3 : ∀ x : obj, InClub x → ChaperoneDances x → ¬ StudentAttendsSchool x
axiom A4 : ∀ x : obj, InClub x → InactiveDisinterested x → ChaperoneDances x
axiom A5 : ∀ x : obj, InClub x → ((YoungChild x ∨ Teenager x) ∧ WishesAcademic x) → StudentAttendsSchool x

-- Bonnie and her properties
axiom Bonnie : obj
axiom B_in : InClub Bonnie
-- Bonnie either (engaged and student) or not (engaged and not student)
axiom B_extra : (EngagedEvents Bonnie ∧ StudentAttendsSchool Bonnie) ∨ ¬ (EngagedEvents Bonnie ∧ ¬ StudentAttendsSchool Bonnie)

theorem bonnie_statement :
  (((YoungChild Bonnie ∨ Teenager Bonnie) ∧ WishesAcademic Bonnie ∧ ChaperoneDances Bonnie)
    ∨ ¬ ((YoungChild Bonnie ∨ Teenager Bonnie) ∧ WishesAcademic Bonnie))
  → (StudentAttendsSchool Bonnie ∨ InactiveDisinterested Bonnie) := by
  intro _
  have hA2 := A2 Bonnie B_in
  exact
    Or.elim hA2
      (fun hPerf =>
        let hEng : EngagedEvents Bonnie := A1 Bonnie B_in hPerf
        Or.elim B_extra
          (fun hES => Or.inl hES.right)
          (fun hNot =>
            -- From ¬(Engaged ∧ ¬Student) and Engaged, deduce Student classically
            have hStu : StudentAttendsSchool Bonnie :=
              Or.elim (Classical.em (StudentAttendsSchool Bonnie))
                (fun hS => hS)
                (fun hSneg => False.elim (hNot ⟨hEng, hSneg⟩))
            Or.inl hStu))
      (fun hInact => Or.inr hInact)
</lean>

ANSWER: True
