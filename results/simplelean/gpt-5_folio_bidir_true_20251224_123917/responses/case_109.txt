<lean>
axiom obj : Type
axiom Peter : obj

axiom Spill : obj → Prop
axiom Tidy : obj → Prop
axiom CFGo : obj → Prop
axiom Cleanly : obj → Prop
axiom ValueOrder : obj → Prop
axiom FamilyOrder : obj → Prop

axiom A1 : ∀ x : obj, Spill x → ¬ Tidy x
axiom A2 : ∀ x : obj, CFGo x → Spill x
axiom A3 : ∀ x : obj, Cleanly x → Tidy x
axiom A4 : ∀ x : obj, ValueOrder x → Cleanly x
axiom A5 : ∀ x : obj, FamilyOrder x → ValueOrder x
axiom A6 : (Spill Peter ∧ Cleanly Peter) ∨ (¬ Spill Peter ∧ ¬ Cleanly Peter)

theorem statement :
  (CFGo Peter ∧ FamilyOrder Peter) ∨ (¬ CFGo Peter ∧ ¬ FamilyOrder Peter) := by
  cases A6 with
  | inl h =>
    have hT : Tidy Peter := A3 Peter h.right
    have hNT : ¬ Tidy Peter := A1 Peter h.left
    exact False.elim (hNT hT)
  | inr h =>
    have hNotCFGo : ¬ CFGo Peter := by
      intro hcfg
      have hspill : Spill Peter := A2 Peter hcfg
      exact h.left hspill
    have hNotFam : ¬ FamilyOrder Peter := by
      intro hfam
      have hval : ValueOrder Peter := A5 Peter hfam
      have hcl : Cleanly Peter := A4 Peter hval
      exact h.right hcl
    exact Or.inr ⟨hNotCFGo, hNotFam⟩
</lean>

ANSWER: True
