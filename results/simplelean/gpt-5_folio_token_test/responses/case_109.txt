<lean>
axiom obj : Type
axiom Peter : obj

axiom Spill : obj → Prop
axiom Tidy : obj → Prop
axiom CF : obj → Prop
axiom Cleanly : obj → Prop
axiom Value : obj → Prop
axiom FamPrior : obj → Prop

-- If people spill a lot of food on their clothing, then they are not notably tidy.
axiom A1 : ∀ x : obj, Spill x → ¬ Tidy x
-- All clumsy foodies who go out frequently to find new food restaurants to try spill a lot of food.
axiom A2 : ∀ x : obj, CF x → Spill x
-- If people are cleanly, then they are notably tidy.
axiom A3 : ∀ x : obj, Cleanly x → Tidy x
-- If people value order and spotlessness, then they are cleanly.
axiom A4 : ∀ x : obj, Value x → Cleanly x
-- All people whose families prioritize order and spotlessness value order and spotlessness.
axiom A5 : ∀ x : obj, FamPrior x → Value x
-- Peter is either (spills and is cleanly) or (does not spill and is not cleanly).
axiom A6 : (Spill Peter ∧ Cleanly Peter) ∨ (¬ Spill Peter ∧ ¬ Cleanly Peter)

theorem peter_equivalence :
  (CF Peter ∧ FamPrior Peter) ∨ (¬ CF Peter ∧ ¬ FamPrior Peter) := by
  -- Show Spill ∧ Cleanly is impossible for Peter
  have hnot : ¬ (Spill Peter ∧ Cleanly Peter) := by
    intro h
    have hs : Spill Peter := And.left h
    have hc : Cleanly Peter := And.right h
    have ht : Tidy Peter := A3 Peter hc
    have hnt : ¬ Tidy Peter := A1 Peter hs
    exact hnt ht
  -- From A6 and hnot, deduce ¬Spill Peter ∧ ¬Cleanly Peter
  have hns_nc : ¬ Spill Peter ∧ ¬ Cleanly Peter := by
    cases A6 with
    | inl hsc => exact False.elim (hnot hsc)
    | inr hnc => exact hnc
  -- From ¬Spill and CF→Spill, get ¬CF
  have hnotCF : ¬ CF Peter := by
    intro hcf
    have hs : Spill Peter := A2 Peter hcf
    exact And.left hns_nc hs
  -- From ¬Cleanly and FamPrior→Value→Cleanly, get ¬FamPrior
  have hnotFam : ¬ FamPrior Peter := by
    intro hfam
    have hv : Value Peter := A5 Peter hfam
    have hc : Cleanly Peter := A4 Peter hv
    exact And.right hns_nc hc
  exact Or.inr (And.intro hnotCF hnotFam)
</lean>

ANSWER: True
