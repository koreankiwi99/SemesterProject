<lean>
axiom obj : Type
axiom John : obj

axiom Alarm : obj → Prop
axiom Ready : obj → Prop
axiom Late : obj → Prop
axiom MissBus : obj → Prop
axiom GotUpLate : obj → Prop
axiom WentToBedLate : obj → Prop

-- If the alarm went off, then it was time to get ready
axiom R1 : ∀ x : obj, Alarm x → Ready x
-- If they missed the bus, then they'd be late for school
axiom R2 : ∀ x : obj, MissBus x → Late x
-- If they got up late, then they miss the bus
axiom R3 : ∀ x : obj, GotUpLate x → MissBus x
-- If they went to bed late, then they get up late
axiom R4 : ∀ x : obj, WentToBedLate x → GotUpLate x
-- Either the alarm went off, or they weren't late for school
axiom R5 : ∀ x : obj, Alarm x ∨ ¬Late x

-- John knows it is not the time to get ready (we take this as ¬Ready John)
axiom T_notReadyJohn : ¬Ready John

theorem john_not_bedlate : ¬WentToBedLate John := by
  -- From ¬Ready John and (Alarm → Ready), get ¬Alarm John
  have hNotAlarm : ¬Alarm John := fun hA => T_notReadyJohn (R1 John hA)
  -- From (Alarm ∨ ¬Late) and ¬Alarm, get ¬Late
  have hNotLate : ¬Late John := by
    cases R5 John with
    | inl hA => exact False.elim (hNotAlarm hA)
    | inr hNL => exact hNL
  -- Chain WentToBedLate → GotUpLate → MissBus → Late
  have hBL_to_Late : WentToBedLate John → Late John :=
    fun hBL => R2 John (R3 John (R4 John hBL))
  -- Conclude ¬WentToBedLate
  exact fun hBL => hNotLate (hBL_to_Late hBL)
</lean>

ANSWER: No
