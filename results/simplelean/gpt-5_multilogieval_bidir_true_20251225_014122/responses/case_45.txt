<lean>
axiom obj : Type
axiom Matt : obj

axiom WatchedDIY : obj → Prop
axiom GainSkills : obj → Prop
axiom RedoLivingRoom : obj → Prop
axiom ReadBlogs : obj → Prop
axiom NewIdeas : obj → Prop

axiom R_watch_gain : ∀ x : obj, WatchedDIY x → GainSkills x
axiom R_gain_redo : ∀ x : obj, GainSkills x → RedoLivingRoom x
axiom Disj_watch_or_blogs : WatchedDIY Matt ∨ ReadBlogs Matt
axiom R_blogs_ideas : ∀ x : obj, ReadBlogs x → NewIdeas x

theorem matt_new_ideas : (¬ RedoLivingRoom Matt) → NewIdeas Matt := by
  intro hNotRedo
  -- from gain -> redo and not redo, get not gain
  have hNotGain : ¬ GainSkills Matt := by
    intro hGain
    have : RedoLivingRoom Matt := R_gain_redo Matt hGain
    exact hNotRedo this
  -- from watched -> gain and not gain, get not watched
  have hNotWatched : ¬ WatchedDIY Matt := by
    intro hW
    have : GainSkills Matt := R_watch_gain Matt hW
    exact hNotGain this
  -- from disjunction and not watched, infer read blogs
  have hReadBlogs : ReadBlogs Matt := by
    cases Disj_watch_or_blogs with
    | inl hW =>
      have : False := hNotWatched hW
      exact False.elim this
    | inr hB =>
      exact hB
  -- then get new ideas
  exact R_blogs_ideas Matt hReadBlogs
</lean>

ANSWER: Yes
